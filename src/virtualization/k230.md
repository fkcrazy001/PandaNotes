# k230_on_qemu

记录一下我在qemu平台上模拟 [K230 soc](https://www.kendryte.com/k230_canmv/zh/main/zh/index.html)，
并兼容使用 RustSbi 作为 Bios 启动的全流程。

最终成果：我们提交了相关patch： <https://lore.kernel.org/qemu-devel/cover.1768884546.git.chao.liu.zevorn@gmail.com>

我的工作记录：
- qemu: <https://github.com/fkcrazy001/qemu-k230>
- rustsbi: <https://github.com/fkcrazy001/rustsbi>

![启动效果图](./images/k230_run.png)

## 初始状态

k230 soc具有两个cpu，我们主要模拟小核的启动的过程。

它基于risc-v指令集架构，目前主要的指令集和寄存器的扩展都已经实现(对于一些非risc-v规范的寄存器，读是返回0，写会被忽略)。
当前可以启动 k230 sdk 的 uboot，更具体的，查看此[issuse](https://github.com/gevico/qemu/issues/1)。


既然能够启动官方的uboot，至少说明cpu的isa和寄存器实现没有太大问题。
uboot有相关输出，说明串口设备的实现也是没有问题的。


## rustsbi 分析

官方地址是：<https://github.com/rustsbi/rustsbi>

我对rust还算熟悉，但是对rustsbi了解不深。 因为之前Arceos项目有用到rustsbi，所以对它的功能还算清楚：
- 它是运行在M态的一个二进制，
- 用类似于系统调用的方式提供了一些调用给S态的内核。
- 此外，它还有分发中断这类的作用。

但是rustsbi项目是如何组织的，以及怎么编译的，这块我是不太了解。不如先提出需求，然后拿着问题去看这个项目吧。

```sh
qemu-system-riscv64 \
    -M k230 \
    -nographic \
    -device loader,file=k230_sdk/output/k230_canmv_defconfig/little/uboot/u-boot.bin,addr=0x8000000
```

### 需求分析

注意到启动命令固定的把uboot.bin放在了 0x8000000 的地方上。那么首先我们要把 rustsbi 也放在这个位置上看看。
这里就给出两个需求：
  - 把rustsbi编译为bin
  - rustsbi 的入口地址应该为 0x8000000

uboot能够输出，说明它肯定以某种方式获取了soc的串口地址。很显然，uboot可以认为是整个cpu上最先启动的程序，那么就没有别人和它说这个地址。
猜测它肯定是builtin了设备树，那么我们肯定也要把设备树增加到rustsbi中。
  - 给 rustsbi 增加设备树

### 需求实现
  
  通过阅读 rustsbi 文档，发现 [prototyper](https://github.com/rustsbi/rustsbi/blob/main/prototyper/README.md) 是我所需要的，
  因为我就需要一个firmware。文档里也给出了编译fdt的办法，通过传递 `--fdt $fdt_file ` 就可以。

  修改rustsbi地址的话文档里就没有了，但是简单的来讲，肯定要去找linker script。因为像这种没有os的程序，肯定是在这里定义了.text段的地址。

  在 `prototyper/prototyper/build.rs` 中 发现了链接脚本。

```rust
const LINKER_SCRIPT: &[u8] = b"OUTPUT_ARCH(riscv)
ENTRY(_start) 
SECTIONS {
    . = 0x80000000;

    . = ALIGN(0x1000); /* Need this to create proper sections */
    sbi_start = .;

    .text : ALIGN(0x1000) { 
        *(.text.entry)
        *(.text .text.*)
    }

    . = ALIGN(0x1000);
    sbi_rodata_start = .;

    .rodata : ALIGN(0x1000) { 
        *(.rodata .rodata.*)
        *(.srodata .srodata.*)
        . = ALIGN(0x1000);  
    } 

    .dynsym : ALIGN(8) {
        *(.dynsym)
    }

    .rela.dyn : ALIGN(8) {
        __rel_dyn_start = .;
        *(.rela*)
        __rel_dyn_end = .;
    }

    . = ALIGN(0x1000);
    sbi_rodata_end = .;

	/*
	 * PMP regions must be to be power-of-2. RX/RW will have separate
	 * regions, so ensure that the split is power-of-2.
	 */
	/* . = ALIGN(1 << LOG2CEIL((SIZEOF(.rodata) + SIZEOF(.text)
				+ SIZEOF(.dynsym) + SIZEOF(.rela.dyn)))); */

    .data : ALIGN(0x1000) { 
        sbi_data_start = .;
        *(.data .data.*)
        *(.sdata .sdata.*)
        . = ALIGN(0x1000); 
        sbi_data_end = .;
    }
    sidata = LOADADDR(.data);

    .bss (NOLOAD) : ALIGN(0x1000) {  
        *(.bss.stack)
        . = ALIGN(0x1000);
        sbi_heap_start = .;
        *(.bss.heap)
        sbi_heap_end = .;
        . = ALIGN(0x1000); 
        sbi_bss_start = .;
        *(.bss .bss.*)
        *(.sbss .sbss.*)
        sbi_bss_end = .;
    } 
    /DISCARD/ : {
        *(.eh_frame)
    }

    . = ALIGN(0x1000);

    .text : ALIGN(0x1000) {
        *(.fdt)
    }
    . = ALIGN(0x1000);
    sbi_end = .;

    .text 0x80200000 : ALIGN(0x1000) {
        *(.payload)
    }
}";

```

不过一般来说，这种代码应该都是PIC的，也就是地址无关的。搜索 0x80000000 发现了 relocation_update 函数, 也确实发现了做了重定位。
所以需求1和2可能不需要做？需求三的话就很简单了，只需要在编译 prototyper 的时候加上 -fdt 参数就可以。

```sh
# 尝试不实现需求1和2，能不能把rustsbi跑起来

# 这个dtb从官方的sdk中找出来
$ cargo prototyper --fdt ./k230_canmv.dtb
$ cd ${qemu_k230} && ./build/qemu-system-riscv64 -M k230 -nographic -device loader,file=${rustsbi}/target/riscv64gc-unknown-none-elf/release/rustsbi-prototyper-dynamic.bin,addr=0x8000000

[RustSBI] INFO  - Hello RustSBI!
[RustSBI] INFO  - RustSBI version 0.4.0
[RustSBI] INFO  - .______       __    __      _______.___________.  _______..______   __
[RustSBI] INFO  - |   _  \     |  |  |  |    /       |           | /       ||   _  \ |  |
[RustSBI] INFO  - |  |_)  |    |  |  |  |   |   (----`---|  |----`|   (----`|  |_)  ||  |
[RustSBI] INFO  - |      /     |  |  |  |    \   \       |  |      \   \    |   _  < |  |
[RustSBI] INFO  - |  |\  \----.|  `--'  |.----)   |      |  |  .----)   |   |  |_)  ||  |
[RustSBI] INFO  - | _| `._____| \______/ |_______/       |__|  |_______/    |______/ |__|
[RustSBI] INFO  - Initializing RustSBI machine-mode environment.
[RustSBI] INFO  - Platform Name                 : kendryte k230 canmv
[RustSBI] INFO  - Platform HART Count           : 1
[RustSBI] INFO  - Enabled HARTs                 : [0]
[RustSBI] WARN  - Platform IPI Device           : Not Available
[RustSBI] INFO  - Platform Console Extension    : Uart16550U32 (Base Address: 0x91400000)
[RustSBI] WARN  - Platform Reset Device         : Not Available
[RustSBI] WARN  - Platform HSM Extension        : Not Available
[RustSBI] WARN  - Platform RFence Extension     : Not Available
[RustSBI] WARN  - Platform SUSP Extension       : Not Available
[RustSBI] WARN  - Platform PMU Extension        : Not Available
[RustSBI] INFO  - Memory range                  : 0x0 - 0x20000000
[RustSBI] INFO  - Platform Status               : Platform initialization complete and ready.
[RustSBI] INFO  - PMP Configuration
[RustSBI] INFO  - PMP   Range      Permission      Address
[RustSBI] INFO  - 0     OFF        NONE            0x0000000000000000
[RustSBI] INFO  - 1     TOR        RWX             0x0000000000000000
[RustSBI] INFO  - 2     TOR        RWX             0x0000000008000000
[RustSBI] INFO  - 3     TOR        R               0x0000000008027000
[RustSBI] INFO  - 4     TOR        NONE            0x0000000008035000
[RustSBI] INFO  - 5     TOR        R               0x0000000008074000
[RustSBI] INFO  - 6     TOR        RWX             0x0000000020000000
[RustSBI] INFO  - 7     TOR        RWX             0xfffffffffffffffc
[RustSBI] INFO  - Boot HART ID                  : 0
[RustSBI] INFO  - Boot HART Privileged Version: : Version1_12
[RustSBI] INFO  - Boot HART MHPM Mask:          : 0x07ffff
[RustSBI] ERROR - No dynamic information available at address 0x0
QEMU: Terminated
```

可以！ 确实看到输出了，这样我们就不用改rustsbi的代码，继续尝试后面的部分了！

### 一个坑

实际测的时候的时候肯定不会像文档这样简单。
所以我记录了最困扰的一个坑：栈溢出。
目前这个问题还没有fix，所以注意不要开启debug模式使用。
https://github.com/rustsbi/rustsbi/issues/172


## start 官方 kernel + initd

如何编译官方sdk以及busybox就不再这里写出来了。
前者在官网上都有的，而后者借助ai等工具也是很简单的事情。不过为了尽可能的使用k230的扩展，要使用官方的compiler。

通过 --kernel 传递进去之后发现现象还是和之前一样， `[RustSBI] ERROR - No dynamic information available at address 0x0`,
查看代码发现这个是去读取了 a2寄存器(soc板卡初始化代码传递的参数)，而boot代码很简单，只是设置了trap然后跳转到 0x8000000 而已。
```c
    /* Mask ROM reset vector */
    uint32_t reset_vec[] = {
        /* 0x91200000: auipc  t0, 0x0              */ 0x00000297,
        /* 0x91200004: addi   t0, t0, 36 # <trap>  */ 0x02428293,
        /* 0x91200008: csrw   mtvec, t0            */ 0x30529073,
        /* 0x9120000C: csrr   a0, misa             */ 0x301012F3,
        /* 0x91200010: lui    t0, 0x1              */ 0x000012B7,
        /* 0x91200014: slli   t0, t0, 1            */ 0x00129293,
        /* 0x91200018: and    t0, a0, t0           */ 0x005572B3,
        /* 0x9120001C: bnez   t0, loop             */ 0x00511063,
        /* entry:                                  */
        /* 0x91200020: addiw  t0, zero, 1          */ 0x0010029b,
        /* 0x91200024: slli   t0, t0, 0x1b         */ 0x01b29293,
        /* 0x91200028: jr     t0 # uboot 0x8000000 */ 0x00028067,
        /* loop:                                   */
        /* 0x9120002C: j      0x9120002C # <loop>  */ 0x0000006f,
        /* trap:                                   */
        /* 0x91200030: j      0x91200030 # <trap>  */ 0x0000006f,
    };

```

在k230.c中可以看到内存布局，`,addr=0x8000000`的作用是把 uboot/rustsbi 给搬到了这个地址上。也就是ram上。

```c
static const MemMapEntry memmap[] = {
    [K230_DEV_DDRC] =         { 0x00000000, 0x80000000 },
    [K230_DEV_KPU_L2_CACHE] = { 0x80000000, 0x00200000 },
    ...
}
```
rustsbi 支持 jump mode, 这样的话我们可以把jump的地址和kernel load的地址都统一掉。
就在我开启jump mode之后，尝试运行后qemu 出现了coredump。

### 碰到的问题一
这个问题具体来说是两个子问题：
- 使用 --bios 将 rustsbi.bin 传递参数，rustsbi也能正常启动 (--bios 默认把rustsbi放在内存起始的地方) @p1
- 自然的，我尝试开启了 -d in_asm 来打印指令，看看为什么能够正常启动，结果qemu 打印了一会儿之后 coredump 了 @p2

```log
./build/qemu-system-riscv64 -M k230 -nographic --bios rustsbi/target/riscv64gc-unknown-none-elf/release/rustsbi-prototyper-jump.bin -d in_asm
...


----------------
IN:
0x0000b376:  6090              ld                      a2,0(s1)
0x0000b378:  6494              ld                      a3,8(s1)
0x0000b37a:  6c88              ld                      a0,24(s1)
0x0000b37c:  708c              ld                      a1,32(s1)
0x0000b37e:  7498              ld                      a4,40(s1)
0x0000b380:  03048813          addi                    a6,s1,48
0x0000b384:  ec2a              sd                      a0,24(sp)
0x0000b386:  f02e              sd                      a1,32(sp)
0x0000b388:  f43a              sd                      a4,40(sp)
0x0000b38a:  01048793          addi                    a5,s1,16
0x0000b38e:  850a              mv                      a0,sp
0x0000b390:  082c              addi                    a1,sp,24
0x0000b392:  874a              mv                      a4,s2
0x0000b394:  ffff5097          auipc                   ra,-11                  # 0x394
0x0000b398:  386080e7          jalr                    ra,ra,902

----------------
IN:
0x0000071a:  Segmentation fault（核心已转储）
```

第一个子问题容易解决，问题在reset_vec的 `/* 0x91200004: addi   t0, t0, 36 # <trap>  */ 0x02428293`, 正确的偏移应该是 0x30, 也就是48,因为
trap的地址在 0x91200030。

不过解决了子问题1，就会spin 住了，之前能跑是因为异常后重新跳到了 `slli   t0, t0, 0x1b`, 这个时候t0会循环进行若干次左移0x1b（别的地址上都没有数据，或者直接就是非法地址）。最终会跑到0x0地址上去。

第二个问题就有点复杂了，先上gdb吧。
```c
(gdb) bt
#0  0x0000155553d8f33d in  () at /usr/lib64/libc.so.6
#1  0x0000555555c3c715 in translator_st (db=0x155552dfb420, dest=0x155552dfb1f6, addr=1818, len=2) at ../accel/tcg/translator.c:428
#2  0x000055555589530e in translator_read_memory (memaddr=1818, myaddr=0x155552dfb1f6 "", length=2, info=0x155552dfb280)
    at ../disas/disas-target.c:17
#3  0x00005555558941ce in print_insn_riscv (memaddr=1818, info=0x155552dfb280, isa=rv64) at ../disas/riscv.c:5479
#4  0x00005555558943e0 in print_insn_riscv64 (memaddr=1818, info=0x155552dfb280) at ../disas/riscv.c:5525
#5  0x000055555589544d in target_disas (out=0x155553df24c0 <_IO_2_1_stderr_>, cpu=0x555556a209c0, db=0x155552dfb420) at ../disas/disas-target.c:47
...
(gdb) frame 1
#1  0x0000555555c3c715 in translator_st (db=0x155552dfb420, dest=0x155552dfb1f6, addr=1818, len=2) at ../accel/tcg/translator.c:428
428	                memcpy(dest, db->host_addr[0] + offset, len);
(gdb) p db->host_addr[0]
$1 = (void *) 0xe2e4d14c545dfa00
```
通过排查，发现是 `translator_st` 的 `db->host_addr[0]` 是一个奇怪的值。
通过调用栈可以看出最早出现在 `tb_gen_code`，下面是这个函数的部分实现。

```c
TranslationBlock *tb_gen_code(CPUState *cpu, TCGTBCPUState s)
{
    void *host_pc;

    phys_pc = get_page_addr_code_hostp(env, s.pc, &host_pc);
    // ...
    if (phys_pc == -1) {
        /* Generate a one-shot TB with 1 insn in it */
        s.cflags = (s.cflags & ~CF_COUNT_MASK) | 1;
    }
    gen_code_size = setjmp_gen_code(env, tb, s.pc, host_pc, &max_insns, &ti);
    // ...
}
```
qemu 的实现也是比较奇怪的，判断 phys_pc == -1 说明这个 get_page_addr_code_hostp 有可能失败，但却没有对  host_pc 赋初始值。
失败的时候也没有对 host_pc 进行处理，就导致 setjmp_gen_code 去访问一个栈上的随机地址，coredump就不奇怪了。

现在问题变成了，为什么 get_page_addr_code_hostp 会返回失败？@p3

不过在此之前，应该先把这个 host_pc 随机值的问题修改一下。无论如何，这是不够健壮的。

修改代码很简单，就一行
```sh
git diff accel/tcg/translate-all.c
diff --git a/accel/tcg/translate-all.c b/accel/tcg/translate-all.c
index d468667..035adf7 100644
--- a/accel/tcg/translate-all.c
+++ b/accel/tcg/translate-all.c
@@ -266,7 +266,7 @@ TranslationBlock *tb_gen_code(CPUState *cpu, TCGTBCPUState s)
     tcg_insn_unit *gen_code_buf;
     int gen_code_size, search_size, max_insns;
     int64_t ti;
-    void *host_pc;
+    void *host_pc = NULL;
 
     assert_memory_lock();
     qemu_thread_jit_write();
```
重新编译后，能够输出了。
现在来解决 p3: 通过 gdb 发现一条mmu中的 full->lg_page_size 为0，也就是1（2^0 = 1），那肯定是谁设置的了这种奇怪的pte。
继续gdb发现了这种设置，如下：
```c
(gdb) bt
#0  tlb_set_page_with_attrs (cpu=0x555556a209c0, addr=1818, paddr=1818, attrs=..., prot=7, mmu_idx=3, size=1) at ../accel/tcg/cputlb.c:1190
#1  0x0000555555c415f4 in tlb_set_page (cpu=0x555556a209c0, addr=1818, paddr=1818, prot=7, mmu_idx=3, size=1) at ../accel/tcg/cputlb.c:1206
#2  0x0000555555cd9a43 in riscv_cpu_tlb_fill
    (cs=0x555556a209c0, address=1818, size=1, access_type=MMU_INST_FETCH, mmu_idx=3, probe=false, retaddr=0) at ../target/riscv/cpu_helper.c:1876
#3  0x0000555555c41783 in tlb_fill_align (cpu=0x555556a209c0, addr=1818, type=MMU_INST_FETCH, mmu_idx=3, memop=MO_8, size=1, probe=false, ra=0)
    at ../accel/tcg/cputlb.c:1257
#4  0x0000555555c41de8 in probe_access_internal
    (cpu=0x555556a209c0, addr=1818, fault_size=1, access_type=MMU_INST_FETCH, mmu_idx=3, nonfault=false, phost=0x155552dfaf30, pfull=0x155552dfaf28, retaddr=0, check_mem_cbs=false) at ../accel/tcg/cputlb.c:1377
(gdb)
```
无他，继续gdb。最终定位到了PMP配置这边。 
```c
tlb_size = pmp_get_tlb_size(env, pa);
target_ulong pmp_get_tlb_size(CPURISCVState *env, hwaddr addr)
{
    // ...
    if (pmp_sa <= tlb_sa && pmp_ea >= tlb_ea) {
        return TARGET_PAGE_SIZE;
    } else if ((pmp_sa >= tlb_sa && pmp_sa <= tlb_ea) ||
                (pmp_ea >= tlb_sa && pmp_ea <= tlb_ea)) {
        return 1;
    }
    // ...
}

```
返回 1 的只有这里，所以继续深入发现这个 1818 这个地址传入的时候，最终会命中 PMP 区域1，这个区域 sa,ea 为 [0,0], 权限为RWX。
这样看起来是rustsbi设置的有问题了。查看启动日志，发现rustsbi pmp 配置如下：
```sh
[RustSBI] INFO  - PMP Configuration
[RustSBI] INFO  - PMP   Range      Permission      Address
[RustSBI] INFO  - 0     OFF        NONE            0x0000000000000000
[RustSBI] INFO  - 1     TOR        RWX             0x0000000000000000
[RustSBI] INFO  - 2     TOR        RWX             0x0000000000000000
[RustSBI] INFO  - 3     TOR        R               0x0000000000027000
[RustSBI] INFO  - 4     TOR        NONE            0x0000000000035000
[RustSBI] INFO  - 5     TOR        R               0x0000000000074000
[RustSBI] INFO  - 6     TOR        RWX             0x0000000020000000
[RustSBI] INFO  - 7     TOR        RWX             0xfffffffffffffffc
```
有两个异常的配置，分别是 PMP 1和PMP 2。 查看rustsbi逻辑, 一次设置 {addr_start, SBI_START_ADDRESS, ...}。
现在 addr_start 是0，SBI_START_ADDRESS也是0，所以就会出现异常的PMP config，让第一个page内的所有指令都没法正常访问。

看起来是rustsbi的问题，想办法修改一下。
不过整体来看，还是这个 0 地址过于特殊了，很多时候都不认为0是一个有效的地址。既然如此，我们skip掉第一个页的ram。

```patch
diff --git a/hw/riscv/k230.c b/hw/riscv/k230.c
index 48540e5..1d0afb4 100644
--- a/hw/riscv/k230.c
+++ b/hw/riscv/k230.c
@@ -395,7 +395,7 @@ static void k230_machine_done(Notifier *notifier, void *data)
     K230MachineState *s = container_of(notifier, K230MachineState,
                                      machine_done);
     MachineState *machine = MACHINE(s);
-    hwaddr start_addr = memmap[K230_DEV_DDRC].base;
+    hwaddr start_addr = memmap[K230_DEV_DDRC].base + 4096;
     target_ulong firmware_end_addr, kernel_start_addr;
     const char *firmware_name = riscv_default_firmware_name(&s->soc.c908_cpu);
     uint64_t kernel_entry = 0;
@@ -407,7 +407,7 @@ static void k230_machine_done(Notifier *notifier, void *data)
     /* Mask ROM reset vector */
     uint32_t reset_vec[] = {
         /* 0x91200000: auipc  t0, 0x0              */ 0x00000297,
-        /* 0x91200004: addi   t0, t0, 0x30 # <trap>  */ 0x02428293,
+        /* 0x91200004: addi   t0, t0, 0x30 # <trap>  */ 0x03028293,
         /* 0x91200008: csrw   mtvec, t0            */ 0x30529073,
         /* 0x9120000C: csrr   a0, misa             */ 0x301012F3,
         /* 0x91200010: lui    t0, 0x1              */ 0x000012B7,
@@ -416,8 +416,8 @@ static void k230_machine_done(Notifier *notifier, void *data)
         /* 0x9120001C: bnez   t0, loop             */ 0x00511063,
         /* entry:                                  */
         /* 0x91200020: addiw  t0, zero, 1          */ 0x0010029b,
-        /* 0x91200024: slli   t0, t0, 0x1b         */ 0x01b29293,
-        /* 0x91200028: jr     t0 # uboot 0x8000000 */ 0x00028067,
+        /* 0x91200024: slli   t0, t0, 0xc          */ 0x00c29293,
+        /* 0x91200028: jr     t0 # uboot 0x1000 */ 0x00028067,
         /* loop:                                   */
         /* 0x9120002C: j      0x9120002C # <loop>  */ 0x0000006f,
         /* trap:                                   */
```

### device tree 修改
原来的k230.c中很多plic和clint的地址与spec/设备上对应不上，导致了rustsbi无法识别设备，打印出 `[RustSBI] ERROR - SBI or IPI device not initialized` 这样的日志，这里统一进行了修改。


### start kernel
现在，可以开始通过 --kernel 参数把 编译好的kernel 传入。 

- jump address 调整
不过需要注意的是，rustsbi jump默认跳转到 0x80200000, 可以在 default.toml 中定义并修改。
现在我们把rustsbi 放在 0x1000的位置，qemu会把kernel放在bios之后,并按照0x200000(64位)进行对齐。 rustsbi的大小没有超过 0x200000，所以kernel就在也就是 0x200000 的地方。

- 巧用qemu调试
  
  关于 qemu 的调试方法，需要包括 trace, monitor, gdb-stub 等等方法，这里给出一个社区link，可以在这儿进行查看。

  通过上面的方法，我发现了原先实现中一些问题，包括：
  - isa中 mmu 扩展没有开启，导致kernel va -> pa 失败
  - isa中 pte 扩展位没有开启，导致qemu翻译va失败
  - chardev 实现不完全，导致kernel probe的时候失败

- kernel参数调整
  启动参数默认使用串口进行通信。但很可能串口本身就有一定的问题(qemu实现的问题/驱动问题)，这个时候使用 sbi 作为早期串口输出，是一个很好的办法，可以让kernel尽可能的输出一些有效信息。通过在设备树 bootargs 中增加 `earlycon=sbi`（需要sbi支持），就可以让kernel打印出早期的panic信息。
```log
[RustSBI] INFO  - Boot HART MHPM Mask:          : 0x07ffff
[RustSBI] INFO  - The patched dtb is located at 0x5c000 with length 0x840.
[RustSBI] INFO  - Redirecting hart 0 to 0x00000000200000 in Supervisor mode.
[    0.000000] Linux version 5.10.4 (root@312917a475fa) (riscv64-unknown-linux-gnu-gcc (Xuantie-900 linux-5.10.4 glibc gcc Toolchain V2.6.0 B-20220715) 10.2.0, GNU ld (GNU Binutils) 2.35) #1 SMP Fri Dec 12 16:28:40 CST 2025
[    0.000000] OF: fdt: Ignoring memory range 0x0 - 0x200000
[    0.000000] earlycon: sbi0 at I/O port 0x0 (options '')
[    0.000000] printk: bootconsole [sbi0] enabled
[    0.000000] efi: UEFI not found.
[    0.000000] cma: Reserved 204 MiB at 0x0000000013400000
[    0.000000] Zone ranges:
[    0.000000]   DMA32    [mem 0x0000000000200000-0x000000001fffffff]
[    0.000000]   Normal   empty
[    0.000000] Movable zone start for each node
[    0.000000] Early memory node ranges
[    0.000000]   node   0: [mem 0x0000000000200000-0x000000001fffffff]
[    0.000000] Initmem setup node 0 [mem 0x0000000000200000-0x000000001fffffff]
[    0.000000] Unable to handle kernel paging request at virtual address ffffffdfffe5c001
[    0.000000] Oops [#1]
[    0.000000] Modules linked in:
[    0.000000] CPU: 0 PID: 0 Comm: swapper Not tainted 5.10.4 #1
[    0.000000] epc: ffffffe00063b1d6 ra : ffffffe000024b18 sp : ffffffe001203f50
[    0.000000]  gp : ffffffe0013b8f08 tp : ffffffe00120c2c0 t0 : ffffffe012afefc0
[    0.000000]  t1 : 0000000100000000 t2 : 0000000000000001 s0 : ffffffe001203f60
[    0.000000]  s1 : ffffffdfffe5c000 a0 : ffffffdfffe5c000 a1 : ffffffe001212a30
[    0.000000]  a2 : 0000000000000000 a3 : 0000000000000000 a4 : 0000000000000000
[    0.000000]  a5 : ffffffdfffe00000 a6 : 0000000000000040 a7 : 0000000000000030
[    0.000000]  s2 : ffffffe0013bc0a8 s3 : 0000000000000000 s4 : ffffffe0013bc060
[    0.000000]  s5 : 0000000000000000 s6 : 0000000000000000 s7 : 0000000000000000
[    0.000000]  s8 : 0000000000000000 s9 : 0000000000000000 s10: 0000000000000000
[    0.000000]  s11: 0000000000000000 t3 : 0000000000000000 t4 : 0000000020000000
[    0.000000]  t5 : 0000000000000000 t6 : 0000000000000018
[    0.000000] status: 0000000200000100 badaddr: ffffffdfffe5c001 cause: 000000000000000d
[    0.000000] random: get_random_bytes called from oops_exit+0x30/0x58 with crng_init=0
[    0.000000] ---[ end trace 0000000000000000 ]---
[    0.000000] Kernel panic - not syncing: Attempted to kill the idle task!
[    0.000000] ---[ end Kernel panic - not syncing: Attempted to kill the idle task! ]---
```

像这里，就可以看到kernel的panic。原因是在访问rustsbi提供dtb的时候panic了。
最终定位到原因应该是官方sdk给出的kernel版本较低，没法处理dtb地址在 load_pa 之前的情况。

- 修改qemu设备树逻辑和 --initd 支持

在前期这么多的工作进行之后，我们终于能够把看到典型的没有fs的报错。现在我们要给 k230 同时增加 --initrd 和 --dtb 支持。

接下来的工作是十分 straight forward的：
  - 从 virt.c 中抄加载代码
  - 把 dtb 的地址传递给rustsbi
  - 让rustsbi不要patch dtb，把qemu patch过的dtb传递给qemu就可以。

```log
[    1.727027] sdhci: Secure Digital Host Controller Interface driver
[    1.727234] sdhci: Copyright(c) Pierre Ossman
[    1.727391] sdhci-pltfm: SDHCI platform and OF driver helper
[    1.729053] ledtrig-cpu: registered to indicate activity on CPUs
[    1.731204] usbcore: registered new interface driver usbhid
[    1.731423] usbhid: USB HID core driver
[    1.735991] NET: Registered protocol family 10
[    1.757214] Segment Routing with IPv6
[    1.758823] sit: IPv6, IPv4 and MPLS over IPv4 tunneling driver
[    1.766306] NET: Registered protocol family 17
[    1.768077] lib80211: common routines for IEEE802.11 drivers
[    1.771520] 9pnet: Installing 9P2000 support
[    1.772414] Key type dns_resolver registered
[    1.774363] Loading compiled-in X.509 certificates
[    1.825022] VFS: Cannot open root device "(null)" or unknown-block(0,0): error -6
[    1.825256] Please append a correct "root=" boot option; here are the available partitions:
[    1.826495] Kernel panic - not syncing: VFS: Unable to mount root fs on unknown-block(0,0)
[    1.827314] CPU: 0 PID: 1 Comm: swapper/0 Not tainted 5.10.4 #1
[    1.827763] Call Trace:
[    1.828194] [<ffffffe000203baa>] walk_stackframe+0x0/0xaa
[    1.828458] [<ffffffe000acdc90>] show_stack+0x32/0x3e
[    1.828591] [<ffffffe000ad25a6>] dump_stack+0x76/0x90
[    1.828721] [<ffffffe000acde46>] panic+0xfc/0x2b2
[    1.828895] [<ffffffe000003252>] mount_block_root+0x1b6/0x24e
[    1.829042] [<ffffffe0000033ea>] mount_root+0x100/0x12a
[    1.829178] [<ffffffe00000354a>] prepare_namespace+0x136/0x16c
[    1.829325] [<ffffffe000002e34>] kernel_init_freeable+0x1b2/0x1ce
[    1.829503] [<ffffffe000adaf8e>] kernel_init+0x12/0x100
[    1.829635] [<ffffffe000201b4a>] ret_from_exception+0x0/0xc
[    1.831423] ---[ end Kernel panic - not syncing: VFS: Unable to mount root fs on unknown-block(0,0) ]---

```



- gdb 调试 relocate 文件
  由于kernel，sbi这种可执行文件都存在加载地址和链接地址不一致的情况。对于简单的线性映射，在gdb调试时可以通过重新add-symbol-file来实现。具体如下：

```gdb
# offset = run_addr - link_addr
(gdb) set $offset = 0x200000 - 0xffffffe000000000
# remove old symbol file
(gdb) symbol-file
(gdb) add-symbol-file /apps/jp/k230_sdk/output/k230_canmv_defconfig/little/linux/vmlinux -o $offset
add symbol table from file "/apps/jp/k230_sdk/output/k230_canmv_defconfig/little/linux/vmlinux" with all sections offset by 0x2000200000
(y or n) y
```

- 一些妥协
  - 一些 page flags 的忽略
    
    t-head 在pte中设计了一些独有的flag，为了提高内存效率。不过需要控制开启额外的 m态 的 csr，详见玄铁spec。
    在不开启相关配置的时候，这些位无效。所以官方sdk默认置位了这些位，但这些位与risc-v的部分位定义冲突，同样的
    也与qemu softmmu冲突。所以为了简单，我们把sdk中下面这些高位全部改为了0。
![pte_flags](./images/thead_pte_flags.png)

  - 串口设备妥协

    ![uart](./images/uart.png)
    ```c
    /* Offsets for the DesignWare specific registers */
    #define DW_UART_DLF     0xc0 /* Divisor Latch Fraction Register */
    #define DW_UART_CPR     0xf4 /* Component Parameter Register */
    #define DW_UART_UCV     0xf8 /* UART Component Version */
    ```
    sdk 中的驱动会访问串口设备的这三个寄存器, 串口本身是 compatible = "snps,dw-apb-uart"。
    qemu对这个设备的实现只有最基础的一些寄存器，导致访问这些寄存器的时候kernel会panic。
    由此我们直接创建了一个unimp设备，这样读返回0，也符合标准。

