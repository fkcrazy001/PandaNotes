# k230_on_qemu

记录一下我在qemu平台上模拟 [K230 soc](https://www.kendryte.com/k230_canmv/zh/main/zh/index.html)，
并兼容使用 RustSbi 作为 Bios 启动的全流程。

最终成果：我们提交了相关patch： <https://lore.kernel.org/qemu-devel/cover.1768884546.git.chao.liu.zevorn@gmail.com>

我的工作记录：
- qemu: <https://github.com/fkcrazy001/qemu-k230>
- rustsbi: <https://github.com/fkcrazy001/rustsbi>

![启动效果图](./images/k230_run.png)

## 初始状态

k230 soc具有两个cpu，我们主要模拟小核的启动的过程。

它基于risc-v指令集架构，目前主要的指令集和寄存器的扩展都已经实现(对于一些非risc-v规范的寄存器，读是返回0，写会被忽略)。
当前可以启动 k230 sdk 的 uboot，更具体的，查看此[issuse](https://github.com/gevico/qemu/issues/1)。


既然能够启动官方的uboot，至少说明cpu的isa和寄存器实现没有太大问题。
uboot有相关输出，说明串口设备的实现也是没有问题的。


## rustsbi 分析

官方地址是：https://github.com/rustsbi/rustsbi

我对rust还算熟悉，但是对rustsbi了解不深。 因为之前Arceos项目有用到rustsbi，所以对它的功能还算清楚：
- 它是运行在M态的一个二进制，
- 用类似于系统调用的方式提供了一些调用给S态的内核。
- 此外，它还有分发中断这类的作用。

但是rustsbi项目是如何组织的，以及怎么编译的，这块我是不太了解。不如先提出需求，然后拿着问题去看这个项目吧。

```sh
qemu-system-riscv64 \
    -M k230 \
    -nographic \
    -device loader,file=k230_sdk/output/k230_canmv_defconfig/little/uboot/u-boot.bin,addr=0x8000000
```

### 需求分析

注意到启动命令固定的把uboot.bin放在了 0x8000000 的地方上。那么首先我们要把 rustsbi 也放在这个位置上看看。
这里就给出两个需求：
  - 把rustsbi编译为bin
  - rustsbi 的入口地址应该为 0x8000000

uboot能够输出，说明它肯定以某种方式获取了soc的串口地址。很显然，uboot可以认为是整个cpu上最先启动的程序，那么就没有别人和它说这个地址。
猜测它肯定是builtin了设备树，那么我们肯定也要把设备树增加到rustsbi中。
  - 给 rustsbi 增加设备树

### 需求实现
  
  通过阅读 rustsbi 文档，发现 [prototyper](https://github.com/rustsbi/rustsbi/blob/main/prototyper/README.md) 是我所需要的，
  因为我就需要一个firmware。文档里也给出了编译fdt的办法，通过传递 `--fdt $fdt_file ` 就可以。

  修改rustsbi地址的话文档里就没有了，但是简单的来讲，肯定要去找linker script。因为像这种没有os的程序，肯定是在这里定义了.text段的地址。

  在 `prototyper/prototyper/build.rs` 中 发现了链接脚本。

```rust
const LINKER_SCRIPT: &[u8] = b"OUTPUT_ARCH(riscv)
ENTRY(_start) 
SECTIONS {
    . = 0x80000000;

    . = ALIGN(0x1000); /* Need this to create proper sections */
    sbi_start = .;

    .text : ALIGN(0x1000) { 
        *(.text.entry)
        *(.text .text.*)
    }

    . = ALIGN(0x1000);
    sbi_rodata_start = .;

    .rodata : ALIGN(0x1000) { 
        *(.rodata .rodata.*)
        *(.srodata .srodata.*)
        . = ALIGN(0x1000);  
    } 

    .dynsym : ALIGN(8) {
        *(.dynsym)
    }

    .rela.dyn : ALIGN(8) {
        __rel_dyn_start = .;
        *(.rela*)
        __rel_dyn_end = .;
    }

    . = ALIGN(0x1000);
    sbi_rodata_end = .;

	/*
	 * PMP regions must be to be power-of-2. RX/RW will have separate
	 * regions, so ensure that the split is power-of-2.
	 */
	/* . = ALIGN(1 << LOG2CEIL((SIZEOF(.rodata) + SIZEOF(.text)
				+ SIZEOF(.dynsym) + SIZEOF(.rela.dyn)))); */

    .data : ALIGN(0x1000) { 
        sbi_data_start = .;
        *(.data .data.*)
        *(.sdata .sdata.*)
        . = ALIGN(0x1000); 
        sbi_data_end = .;
    }
    sidata = LOADADDR(.data);

    .bss (NOLOAD) : ALIGN(0x1000) {  
        *(.bss.stack)
        . = ALIGN(0x1000);
        sbi_heap_start = .;
        *(.bss.heap)
        sbi_heap_end = .;
        . = ALIGN(0x1000); 
        sbi_bss_start = .;
        *(.bss .bss.*)
        *(.sbss .sbss.*)
        sbi_bss_end = .;
    } 
    /DISCARD/ : {
        *(.eh_frame)
    }

    . = ALIGN(0x1000);

    .text : ALIGN(0x1000) {
        *(.fdt)
    }
    . = ALIGN(0x1000);
    sbi_end = .;

    .text 0x80200000 : ALIGN(0x1000) {
        *(.payload)
    }
}";

```

    不过一般来说，这种代码应该都是PIC的，也就是地址无关的。搜索 0x80000000 发现了 relocation_update 函数, 也确实发现了做了重定位。
    所以需求1和2可能不需要做？需求三的话就很简单了，只需要在编译 prototyper 的时候加上 -fdt 参数就可以。

```sh
# 尝试不实现需求1和2，能不能把rustsbi跑起来

# 这个dtb从官方的sdk中找出来
$ cargo prototyper --fdt ./k230_canmv.dtb
$ cd ${qemu_k230} && ./build/qemu-system-riscv64 -M k230 -nographic -device loader,file=${rustsbi}/target/riscv64gc-unknown-none-elf/release/rustsbi-prototyper-dynamic.bin,addr=0x8000000

[RustSBI] INFO  - Hello RustSBI!
[RustSBI] INFO  - RustSBI version 0.4.0
[RustSBI] INFO  - .______       __    __      _______.___________.  _______..______   __
[RustSBI] INFO  - |   _  \     |  |  |  |    /       |           | /       ||   _  \ |  |
[RustSBI] INFO  - |  |_)  |    |  |  |  |   |   (----`---|  |----`|   (----`|  |_)  ||  |
[RustSBI] INFO  - |      /     |  |  |  |    \   \       |  |      \   \    |   _  < |  |
[RustSBI] INFO  - |  |\  \----.|  `--'  |.----)   |      |  |  .----)   |   |  |_)  ||  |
[RustSBI] INFO  - | _| `._____| \______/ |_______/       |__|  |_______/    |______/ |__|
[RustSBI] INFO  - Initializing RustSBI machine-mode environment.
[RustSBI] INFO  - Platform Name                 : kendryte k230 canmv
[RustSBI] INFO  - Platform HART Count           : 1
[RustSBI] INFO  - Enabled HARTs                 : [0]
[RustSBI] WARN  - Platform IPI Device           : Not Available
[RustSBI] INFO  - Platform Console Extension    : Uart16550U32 (Base Address: 0x91400000)
[RustSBI] WARN  - Platform Reset Device         : Not Available
[RustSBI] WARN  - Platform HSM Extension        : Not Available
[RustSBI] WARN  - Platform RFence Extension     : Not Available
[RustSBI] WARN  - Platform SUSP Extension       : Not Available
[RustSBI] WARN  - Platform PMU Extension        : Not Available
[RustSBI] INFO  - Memory range                  : 0x0 - 0x20000000
[RustSBI] INFO  - Platform Status               : Platform initialization complete and ready.
[RustSBI] INFO  - PMP Configuration
[RustSBI] INFO  - PMP   Range      Permission      Address
[RustSBI] INFO  - 0     OFF        NONE            0x0000000000000000
[RustSBI] INFO  - 1     TOR        RWX             0x0000000000000000
[RustSBI] INFO  - 2     TOR        RWX             0x0000000008000000
[RustSBI] INFO  - 3     TOR        R               0x0000000008027000
[RustSBI] INFO  - 4     TOR        NONE            0x0000000008035000
[RustSBI] INFO  - 5     TOR        R               0x0000000008074000
[RustSBI] INFO  - 6     TOR        RWX             0x0000000020000000
[RustSBI] INFO  - 7     TOR        RWX             0xfffffffffffffffc
[RustSBI] INFO  - Boot HART ID                  : 0
[RustSBI] INFO  - Boot HART Privileged Version: : Version1_12
[RustSBI] INFO  - Boot HART MHPM Mask:          : 0x07ffff
[RustSBI] ERROR - No dynamic information available at address 0x0
QEMU: Terminated
```

可以！ 确实看到输出了，这样我们就不用改rustsbi的代码，继续尝试后面的部分了！

### 一个坑

实际实现的时候肯定比文档要麻烦的多，其中的坑更是数不胜数。

这里我记录了最不明显，也是最困扰的一个坑：栈溢出。
目前这个问题还没有fix，所以注意不要开启debug模式使用。
https://github.com/rustsbi/rustsbi/issues/172


## start 官方 kernel + initd

如何编译官方sdk以及busybox就不再这里写出来了。
前者在官网上都有的，而后者借助ai等工具也是很简单的事情。不过为了尽可能的使用k230的扩展，要使用官方的compiler。

通过 --kernel 传递进去之后发现现象还是和之前一样， `[RustSBI] ERROR - No dynamic information available at address 0x0`,
查看代码发现这个是去读取了 a2寄存器(soc板卡初始化代码传递的参数)，而boot代码很简单，只是设置了trap然后跳转到 0x8000000 而已。
```c
    /* Mask ROM reset vector */
    uint32_t reset_vec[] = {
        /* 0x91200000: auipc  t0, 0x0              */ 0x00000297,
        /* 0x91200004: addi   t0, t0, 36 # <trap>  */ 0x02428293,
        /* 0x91200008: csrw   mtvec, t0            */ 0x30529073,
        /* 0x9120000C: csrr   a0, misa             */ 0x301012F3,
        /* 0x91200010: lui    t0, 0x1              */ 0x000012B7,
        /* 0x91200014: slli   t0, t0, 1            */ 0x00129293,
        /* 0x91200018: and    t0, a0, t0           */ 0x005572B3,
        /* 0x9120001C: bnez   t0, loop             */ 0x00511063,
        /* entry:                                  */
        /* 0x91200020: addiw  t0, zero, 1          */ 0x0010029b,
        /* 0x91200024: slli   t0, t0, 0x1b         */ 0x01b29293,
        /* 0x91200028: jr     t0 # uboot 0x8000000 */ 0x00028067,
        /* loop:                                   */
        /* 0x9120002C: j      0x9120002C # <loop>  */ 0x0000006f,
        /* trap:                                   */
        /* 0x91200030: j      0x91200030 # <trap>  */ 0x0000006f,
    };

```

在k230.c中可以看到内存布局，`,addr=0x8000000`的作用是把 uboot/rustsbi 给搬到了这个地址上。也就是ram上。

```c
static const MemMapEntry memmap[] = {
    [K230_DEV_DDRC] =         { 0x00000000, 0x80000000 },
    [K230_DEV_KPU_L2_CACHE] = { 0x80000000, 0x00200000 },
    ...
}
```
rustsbi 支持 jump mode, 这样的话我们可以把jump的地址和kernel load的地址都统一掉。
就在我开启jump mode之后，尝试运行后qemu 出现了coredump。

### 碰到的问题一
这个问题具体来说是两个子问题：
- 使用 --bios 将 rustsbi.bin 传递参数，rustsbi也能正常启动 (--bios 默认把rustsbi放在内存起始的地方) @p1
- 自然的，我尝试开启了 -d in_asm 来打印指令，看看为什么能够正常启动，结果qemu 打印了一会儿之后 coredump 了 @p2

```log
./build/qemu-system-riscv64 -M k230 -nographic --bios rustsbi/target/riscv64gc-unknown-none-elf/release/rustsbi-prototyper-jump.bin -d in_asm
...


----------------
IN:
0x0000b376:  6090              ld                      a2,0(s1)
0x0000b378:  6494              ld                      a3,8(s1)
0x0000b37a:  6c88              ld                      a0,24(s1)
0x0000b37c:  708c              ld                      a1,32(s1)
0x0000b37e:  7498              ld                      a4,40(s1)
0x0000b380:  03048813          addi                    a6,s1,48
0x0000b384:  ec2a              sd                      a0,24(sp)
0x0000b386:  f02e              sd                      a1,32(sp)
0x0000b388:  f43a              sd                      a4,40(sp)
0x0000b38a:  01048793          addi                    a5,s1,16
0x0000b38e:  850a              mv                      a0,sp
0x0000b390:  082c              addi                    a1,sp,24
0x0000b392:  874a              mv                      a4,s2
0x0000b394:  ffff5097          auipc                   ra,-11                  # 0x394
0x0000b398:  386080e7          jalr                    ra,ra,902

----------------
IN:
0x0000071a:  Segmentation fault（核心已转储）
```

第一个子问题容易解决，问题在reset_vec的 `/* 0x91200004: addi   t0, t0, 36 # <trap>  */ 0x02428293`, 正确的偏移应该是 0x30, 也就是48,因为
trap的地址在 0x91200030。

不过解决了子问题1，就会spin 住了，之前能跑是因为异常后重新跳到了 `slli   t0, t0, 0x1b`, 这个时候t0会循环进行若干次左移0x1b（别的地址上都没有数据，或者直接就是非法地址）。最终会跑到0x0地址上去。

第二个问题就有点复杂了，先上gdb吧。
```c
(gdb) bt
#0  0x0000155553d8f33d in  () at /usr/lib64/libc.so.6
#1  0x0000555555c3c715 in translator_st (db=0x155552dfb420, dest=0x155552dfb1f6, addr=1818, len=2) at ../accel/tcg/translator.c:428
#2  0x000055555589530e in translator_read_memory (memaddr=1818, myaddr=0x155552dfb1f6 "", length=2, info=0x155552dfb280)
    at ../disas/disas-target.c:17
#3  0x00005555558941ce in print_insn_riscv (memaddr=1818, info=0x155552dfb280, isa=rv64) at ../disas/riscv.c:5479
#4  0x00005555558943e0 in print_insn_riscv64 (memaddr=1818, info=0x155552dfb280) at ../disas/riscv.c:5525
#5  0x000055555589544d in target_disas (out=0x155553df24c0 <_IO_2_1_stderr_>, cpu=0x555556a209c0, db=0x155552dfb420) at ../disas/disas-target.c:47
...
(gdb) frame 1
#1  0x0000555555c3c715 in translator_st (db=0x155552dfb420, dest=0x155552dfb1f6, addr=1818, len=2) at ../accel/tcg/translator.c:428
428	                memcpy(dest, db->host_addr[0] + offset, len);
(gdb) p db->host_addr[0]
$1 = (void *) 0xe2e4d14c545dfa00
```
通过排查，发现是 `translator_st` 的 `db->host_addr[0]` 是一个奇怪的值。
通过调用栈可以看出最早出现在 `tb_gen_code`，下面是这个函数的部分实现。

```c
TranslationBlock *tb_gen_code(CPUState *cpu, TCGTBCPUState s)
{
    void *host_pc;

    phys_pc = get_page_addr_code_hostp(env, s.pc, &host_pc);
    // ...
    if (phys_pc == -1) {
        /* Generate a one-shot TB with 1 insn in it */
        s.cflags = (s.cflags & ~CF_COUNT_MASK) | 1;
    }
    gen_code_size = setjmp_gen_code(env, tb, s.pc, host_pc, &max_insns, &ti);
    // ...
}
```
qemu 的实现也是比较奇怪的，判断 phys_pc == -1 说明这个 get_page_addr_code_hostp 有可能失败，但却没有对  host_pc 赋初始值。
失败的时候也没有对 host_pc 进行处理，就导致 setjmp_gen_code 去访问一个栈上的随机地址，coredump就不奇怪了。

现在问题变成了，为什么 get_page_addr_code_hostp 会返回失败？@p3

不过在此之前，应该先把这个 host_pc 随机值的问题修改一下。无论如何，这是不够健壮的。

修改代码很简单，就一行
```sh
git diff accel/tcg/translate-all.c
diff --git a/accel/tcg/translate-all.c b/accel/tcg/translate-all.c
index d468667..035adf7 100644
--- a/accel/tcg/translate-all.c
+++ b/accel/tcg/translate-all.c
@@ -266,7 +266,7 @@ TranslationBlock *tb_gen_code(CPUState *cpu, TCGTBCPUState s)
     tcg_insn_unit *gen_code_buf;
     int gen_code_size, search_size, max_insns;
     int64_t ti;
-    void *host_pc;
+    void *host_pc = NULL;
 
     assert_memory_lock();
     qemu_thread_jit_write();
```
重新编译后，能够输出了。
现在来解决 p3: 通过 gdb 发现一条mmu中的 full->lg_page_size 为0，也就是1（2^0 = 1），那肯定是谁设置的了这种奇怪的pte。
继续gdb发现了这种设置，如下：
```c
(gdb) bt
#0  tlb_set_page_with_attrs (cpu=0x555556a209c0, addr=1818, paddr=1818, attrs=..., prot=7, mmu_idx=3, size=1) at ../accel/tcg/cputlb.c:1190
#1  0x0000555555c415f4 in tlb_set_page (cpu=0x555556a209c0, addr=1818, paddr=1818, prot=7, mmu_idx=3, size=1) at ../accel/tcg/cputlb.c:1206
#2  0x0000555555cd9a43 in riscv_cpu_tlb_fill
    (cs=0x555556a209c0, address=1818, size=1, access_type=MMU_INST_FETCH, mmu_idx=3, probe=false, retaddr=0) at ../target/riscv/cpu_helper.c:1876
#3  0x0000555555c41783 in tlb_fill_align (cpu=0x555556a209c0, addr=1818, type=MMU_INST_FETCH, mmu_idx=3, memop=MO_8, size=1, probe=false, ra=0)
    at ../accel/tcg/cputlb.c:1257
#4  0x0000555555c41de8 in probe_access_internal
    (cpu=0x555556a209c0, addr=1818, fault_size=1, access_type=MMU_INST_FETCH, mmu_idx=3, nonfault=false, phost=0x155552dfaf30, pfull=0x155552dfaf28, retaddr=0, check_mem_cbs=false) at ../accel/tcg/cputlb.c:1377
(gdb)
```
无他，继续gdb。最终定位到了PMP配置这边。 
```c
tlb_size = pmp_get_tlb_size(env, pa);
target_ulong pmp_get_tlb_size(CPURISCVState *env, hwaddr addr)
{
    // ...
    if (pmp_sa <= tlb_sa && pmp_ea >= tlb_ea) {
        return TARGET_PAGE_SIZE;
    } else if ((pmp_sa >= tlb_sa && pmp_sa <= tlb_ea) ||
                (pmp_ea >= tlb_sa && pmp_ea <= tlb_ea)) {
        return 1;
    }
    // ...
}

```
返回 1 的只有这里，所以继续深入发现这个 1818 这个地址传入的时候，最终会命中 PMP 区域1，这个区域 sa,ea 为 [0,0], 权限为RWX。
这样看起来是rustsbi设置的有问题了。查看启动日志，发现rustsbi pmp 配置如下：
```sh
[RustSBI] INFO  - PMP Configuration
[RustSBI] INFO  - PMP   Range      Permission      Address
[RustSBI] INFO  - 0     OFF        NONE            0x0000000000000000
[RustSBI] INFO  - 1     TOR        RWX             0x0000000000000000
[RustSBI] INFO  - 2     TOR        RWX             0x0000000000000000
[RustSBI] INFO  - 3     TOR        R               0x0000000000027000
[RustSBI] INFO  - 4     TOR        NONE            0x0000000000035000
[RustSBI] INFO  - 5     TOR        R               0x0000000000074000
[RustSBI] INFO  - 6     TOR        RWX             0x0000000020000000
[RustSBI] INFO  - 7     TOR        RWX             0xfffffffffffffffc
```
有两个异常的配置，分别是 PMP 1和PMP 2。 查看rustsbi逻辑, 一次设置 {addr_start, SBI_START_ADDRESS, ...}。
现在 addr_start 是0，SBI_START_ADDRESS也是0，所以就会出现异常的PMP config，让第一个page内的所有指令都没法正常访问。

看起来是rustsbi的问题，想办法修改一下。

### 一些妥协
- 一些 page flags 的忽略
  
- 
