# 线段树 (Segment Tree)

理解的不多了，只知道这是一个用来处理数组 **区间查询** 和 **区间修改** 的高级数据结构。
相比于普通数组 \\( O(N) \\) 的修改或查询复杂度，线段树可以将这两者都优化到 \\( O(\log N) \\)。

## 问题描述

有一个长度为 \\( N \\) 的数组 `arr` (\\( 0 \dots N-1 \\))。
我们需要频繁进行以下两种操作：
1. **单点修改**：将 `arr[i]` 的值修改为 \\( v \\)。
2. **区间查询**：计算 `arr[L,R]` 之间的和（或者最大值、最小值等）。

如果不使用线段树：
- 直接数组：修改 \\( O(1) \\)，查询 \\( O(N) \\)。
- 前缀和：修改 \\( O(N) \\)，查询 \\( O(1) \\)。

线段树可以使两者均为：

\\[ O(\log N) \\]

## 算法

线段树本质上是一棵 **二叉树**。
- 根节点表示整个区间 \\( [0, N-1] \\)。
- 每个节点代表一个区间 \\( [L, R] \\)，其左子节点代表 \\( [L, mid] \\)，右子节点代表 \\( [mid+1, R] \\)。
- 叶子节点代表单点 \\( [i, i] \\)。

通常使用 4倍大小的数组 `tree` 来存储这棵树。

```py3
# 假设 arr 长度为 N
# tree 数组长度通常开到 4 * N
tree = [0] * (4 * N)

# 1. 建树 (Build)
# node: 当前树节点下标 (从1开始), start/end: 当前节点对应的区间范围
def build(node, start, end):
    if start == end:
        tree[node] = arr[start]
        return
    
    mid = (start + end) // 2
    left_node  = node * 2
    right_node = node * 2 + 1
    
    build(left_node, start, mid)
    build(right_node, mid + 1, end)
    
    # Push Up: 当前节点的值等于左右子节点值的聚合（这里以求和为例）
    tree[node] = tree[left_node] + tree[right_node]

# 2. 单点修改 (Update)
# 将 arr[idx] 修改为 val
def update(node, start, end, idx, val):
    if start == end:
        tree[node] = val
        return

    mid = (start + end) // 2
    left_node  = node * 2
    right_node = node * 2 + 1
    
    if idx <= mid:
        update(left_node, start, mid, idx, val)
    else:
        update(right_node, mid + 1, end, idx, val)
        
    # 修改完子节点后，记得更新当前节点
    tree[node] = tree[left_node] + tree[right_node]

# 3. 区间查询 (Query)
# 查询区间 [L, R] 的和
def query(node, start, end, L, R):
    # 如果当前节点区间完全包含在查询区间内，直接返回
    if L <= start and end <= R:
        return tree[node]
    
    mid = (start + end) // 2
    left_node  = node * 2
    right_node = node * 2 + 1
    
    res = 0
    # 如果左子区间和 [L, R] 有交集
    if L <= mid:
        res += query(left_node, start, mid, L, R)
    # 如果右子区间和 [L, R] 有交集
    if R > mid:
        res += query(right_node, mid + 1, end, L, R)
        
    return res
```

## 证明 (原理)

线段树利用了 **分治 (Divide and Conquer)** 的思想。

1. **结构**：我们将一个大区间不断二分，直到长度为1。这就构成了一棵高度为 \\( \lceil \log_2 N \rceil \\) 的二叉树。
2. **覆盖**：任意一个区间 \\( [L, R] \\)，都可以被分解为线段树上不超过 \\( 2 \log N \\) 个节点的并集。
   - 例如查询 \\( [0, 5] \\)，可能会被拆分为节点 \\( [0, 3] \\) 和节点 \\( [4, 5] \\) 的组合。
3. **复杂度**：
   - **Build**: 树的节点总数约为 \\( 2N \\) (甚至更接近 \\( 4N \\) 的存储空间)，每个节点访问一次，复杂度 \\( O(N) \\)。
   - **Update**: 从根走到叶子，深度为 \\( \log N \\)，路径上的节点都需要更新，复杂度 \\( O(\log N) \\)。
   - **Query**: 每一层最多访问 2-4 个节点（因为我们只关心重叠部分），总共访问 \\( O(\log N) \\) 个节点。

### 进阶优化：Lazy Propagation (懒标记)

如果需要 **区间修改** (例如将 \\( [L, R] \\) 范围内的所有数都 +1)，单点修改的方法会退化成 \\( O(N) \\)。
为了保持 \\( O(\log N) \\)，引入 **懒标记 (Lazy Tag)**。

原理：
- 当修改一个区间 \\( [L, R] \\) 时，如果当前节点完全包含在 \\( [L, R] \\) 内，我们只更新当前节点的值，并打上一个标记 `lazy[node]`，表示 "下面的子节点还没更新，先欠着"。
- **不下放**：除非下次查询或修改需要进入该节点的子节点，否则这个标记一直保留。
- **下放 (Push Down)**：一旦需要进入子节点，就将当前的标记传给左右子节点，并清除当前标记。

```py3
# 伪代码逻辑
def push_down(node, start, end):
    if lazy[node] != 0:
        mid = (start + end) // 2
        # 下放标记给左子节点
        lazy[node*2] += lazy[node]
        tree[node*2] += lazy[node] * (mid - start + 1)
        # 下放标记给右子节点
        lazy[node*2+1] += lazy[node]
        tree[node*2+1] += lazy[node] * (end - mid)
        #以此类推...
        lazy[node] = 0
```
