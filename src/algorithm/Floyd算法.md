# Floyd 算法

理解的不多了，目前只知道这个算法是用来算 有向图/无向图 中每个点到其它每个点的最短距离。 
和 dijkstra 算法很像，不过后者是算单点到单点的，而且后者没法处理负权边。

## 问题描述

有 N 个点（0..n-1），g[N][N] 是一个有向图，其中 g[i][j] == inf 说明这两个点之间没有直接连接,
其他情况则说明有一条有向边，权重为 g[i][j] (正负都可以)

需要给出 cost[N][N], 其中 cost[i][j] 为从i点到j点需要的最短距离。


## 算法

```py3
# 初始状态
cost = g

for k in range(N):
    for i in range(N):
        for j in range(N):
            cost[i][j] = min(cost[i][j], cost[i][k],cost[k][j])
```

## 证明

设置 dp 为 [k][i][j] 的数组，其中 0<= i,j,k < n

k 表示使用前面k个点的情况下，使得点i到点j的最短距离。

那么很显然，当 k = 0 时， dp[0][i][j] = g[i][j]

当 k > 0时, dp[k][i][j]  = 
- 要么不使用新加入节点 k-1，这种情况下最短距离为 dp[k-1][i][j]
- 要么使用新加入的节点 k-1，这种情况下，最短距离为 dp[k-1][i][k-1] + dp[k-1][k-1][j]

由此，k > 0是，dp[k][i][j] = min(dp[k-1][i][j],  dp[k-1][i][k-1] + dp[k-1][k-1][j])

### 空间优化

dp[k] 明显只与 dp[k-1] 状态有关，所以这里可以做一次空间优化。
```py3
# 0<= k < n, 0<= i < n, 0<= j < n
dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j]) 
```